<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>PersistedConcurrentSortedList</name></assembly>
<members>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Item(`0,`1)">
<summary>
 访问 Item：带线程锁的读写访问
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.ValuesSafe">
<summary>
 获取所有 Values - Safe 版本 表 QUEUE 完成後取值
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Values">
<summary>
 获取所有 Values 版本
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.KeysSafe">
<summary>
 获取所有 Keys - Safe 版本 表 QUEUE 完成後取值
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Keys">
<summary>
 获取所有 Keys 版本
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Item(`0)">
<summary>
 访问 Item：带线程锁的读写访问
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.CountSafe">
<summary>
 获取 Count - Safe 版本 表 QUEUE 完成後取值
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Count">
<summary>
 获取 Count 版本
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Update(`0,`1)">
<summary>
 TryUpdate 方法：将更新操作封装为任务并执行
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.TryUpdateBase(`0,`1)">
<summary>
 尝试更新，如果键存在则更新值
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.TryRemoveBase(`0)">
<summary>
 基础的 Remove 操作
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.TryAddBase(`0,`1)">
<summary>
 基础的 Add 操作（直接修改内部数据结构）
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Remove(`0)">
<summary>
 Remove 方法：将移除操作封装为任务并执行
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.LockableOps(PersistedConcurrentSortedList.CSL.Op{`0,`1},Microsoft.FSharp.Core.FSharpOption{System.Guid})">
<summary>
 封装操作并添加到任务队列，执行后返回 Task
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.GetValue(`0)">
<summary>
 TryGetValue 同步获取值，不需要队列
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.ContainsKeySafe(`0)">
<summary>
 Safe 版本 表 QUEUE 完成後取值
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.CleanSafe">
<summary>
 清空列表 - Safe 版本 表 QUEUE 完成後取值
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Clean">
<summary>
 清空列表 版本
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.CSL.ConcurrentSortedList`4.Add(`0,`1)">
<summary>
 Add 方法：将添加操作封装为任务并执行
</summary>
</member>
<member name="M:PersistedConcurrentSortedList.Task.tryGetResultWithTimeout``1(System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
<summary>
[DEPRECATED]
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.PCSL.PersistedConcurrentSortedList`2.PersistKeyValues">
<summary>
persist 之後留在 buffer (不涉及寫入 base sortedList)
</summary>
</member>
<member name="P:PersistedConcurrentSortedList.PCSL.PersistedConcurrentSortedList`2.PersistKeyValueRemove">
<summary>
persist 之後移出 buffer (不涉及寫入 base sortedList)
</summary>
</member>
</members>
</doc>
